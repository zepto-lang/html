(module "html"
  (export
    (list "doctype" doctype)
    (list "build" build)
    (list "with-skeleton" with-skeleton)
    (list "parse" parse))

  (find-substr (lambda (str sub)
    (define (internal s p i)
      (if (< (length s) (length p))
       -1
        (let ((m (substring s 0 (length p))))
          (if (string=? m p)
            i
            (let ((x (add1 (string:find (string:tail s) (string:head p)))))
              (if (< x 1)
                -1
                (internal (substring s x (length s)) p (+ i x))))))))
    (internal str sub 0)))

  (doctype (lambda x
    (if (null? x)
      "<!DOCTYPE html>"
      (++ "<!DOCTYPE " (car x) ">"))))

  (parse (lambda (str)
    (define (split-attrs tag-contents parsed)
      (if (string:empty? tag-contents)
        parsed
        (let ((quoted (string:find tag-contents #\"))
              (whitespace (string:find tag-contents #\space)))
        (if (< quoted whitespace)
          (let ((sep (add1 
                  (+
                    (string:find
                      (substring tag-contents (add1 quoted) (length tag-contents)) #\") quoted))))
            (if (eq? sep 0)
              :err-quote-mismatch
              (split-attrs (substring tag-contents (add1 sep) (length tag-contents))
                           (++ parsed (substring tag-contents 0 (add1 sep))))))
          (if (eq? whitespace -1)
            (++ parsed tag-contents)
            (if (eq? whitespace 0)
              (split-attrs (substring tag-contents (add1 whitespace) (length tag-contents))
                           parsed)
              (split-attrs (substring tag-contents (add1 whitespace) (length tag-contents))
                           (++ parsed (substring tag-contents 0 whitespace)))))))))
    (define (parse-self-closing tag)
      (let* ((attrs (split-attrs tag []))
             (name (car attrs))
             (pairs
              (make-hash
                (map
                  (lambda (x) 
                    (let* ((split (string:split x #\=))
                           (val (cadr split)))
                      (list (car split) (substring val 1 (sub1 (length val))))))
                  (cdr attrs)))))
      (list name pairs)))
    (define (parse-regular tag str)
      (let* ((name (car (split-attrs tag [])))
             (close (++ "</" name ">"))
             (pos (find-substr str close)))
        (if (= -1 pos)
          (begin
            (error "html:parse" "Error" "Unclosed tag: " tag)
            :err-no-closing)
          (let* ((sub (substring str (+ (length tag) 2) pos))
                 (sub-pos (string:find sub #\<)))
            (list (+ pos (length close))
                  (++ (parse-self-closing tag)
                  (if (= sub-pos -1) sub (list (internal (substring sub sub-pos (length sub))
                                                         (+ pos sub-pos) [])))))))))
    (define (internal str pos acc)
      (if (string:empty? str)
        acc
        (let ((strip (string:head str)))
          (if (eq? strip #\<)
            (let ((closing (string:find str #\>)))
              (if (eq? closing -1)
                (begin
                  (error "html:parse" "Error at position" pos "Unclosed bracket")
                  :err-unclosed-bracket)
                (let* ((tag (substring str 1 closing))
                       (len (+ (length tag) 2)))
                  (if (string:ends-with tag "/")
                    (internal
                      (substring str len (length str))
                      (+ pos len)
                      (+= acc (parse-self-closing (substring tag 0 (sub1 (length tag))))))
                    (let ((state (parse-regular tag str)))
                      (if (atom? state)
                        state
                      (let ((new-p (car state)))
                        (internal (substring str new-p (length str))
                                  (+ pos new-p)
                                  (+= acc (cadr state))))))))))
            (begin
              (error "html:parse" "Error at position: " pos "Expected '<', got " strip)
              :err-unexpected-char)))))
    (internal str 0 [])))

  (build (lambda (m)
    (define (_build l)
      (define (destructure hash)
        (hash:keys-reduce (lambda (acc x) (++ acc " " x "=\"" (hash x) "\"")) "" hash))
      (let* ((tag (car l))
             (len (length l))
             (sattrs (if (> len 1) (if (hash-map? (cadr l)) #t #f) #f))
             (attrs (if sattrs (destructure (cadr l)) ""))
             (todo (if sattrs (if (> len 2) (caddr l) '()) (if (> len 1) (cadr l) ""))))
        (++ "<" tag attrs ">" (build todo) "</" tag ">")))
    (cond
      ((string? m) m)
      ((number? m) (number->string m))
      ((list? m)
        (cond
          ((null? m) "")
          ((string? (car m)) (_build m))
          ((list? (car m)) (reduce (lambda (acc x) (++ acc (build x))) "" m))
          (else :no)))
      (else :no))))

    (with-skeleton (lambda contents
      (if (null? contents)
        (list "html" ((list "head") (list "body")))
        (let ((hash (car contents)))
          (list "html"
            (list
              (list "head" (if (truthy? (hash "head")) (hash "head") ""))
              (list "body" (if (truthy? (hash "body")) (hash "body") "")))))))))
